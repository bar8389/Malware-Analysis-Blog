# Multi-stage Infection Chain Analysis
### Executive Summary
In this malware analysis blog, we will be analysing a multi-stage infection chain that ultimately drops an unknown malware onto the victim's machine. The infection process for this malware is complex and involves multiple stages, in which different pieces of malware are being generated and executed in sequence. By analysing each stage of the infection chain, we hope to gain a better understanding of the tactics and techniques being used by the attackers and to identify any indicators of compromise (IOCs) that might be used to detect and defend against this malware. Since at the time of writing this blog the C2 server appears to be down, I couldn’t determine what malware family is downloaded at the last stage. 
 
![image](https://user-images.githubusercontent.com/44728938/211385082-e242b65d-297e-4fb0-bb0e-20c6a07d6efb.png)

### Stage 1: EmbedDLL.dll
The first stage of the infection chain, we obtained a DLL file from an unknown source. Initial examination showed that the dll had been had been compiled by .NET framework.
Upon further analysis, helped by dnSpy to analysis .NET executables, we discovered that the DLL, originally named EmbedDLL.dll, contained two classes:
* Cryptor- to encrypt and decrypt byte array by AES method
* Program- has two functions:
* Embed()-the primary part of the file, designed to perform a number of malicious activities. 
* Main() - empty
 
 ![image](https://user-images.githubusercontent.com/44728938/211385122-e53faa68-cb02-4304-ab2c-a895cc8a6a0c.png)
  
 ![image](https://user-images.githubusercontent.com/44728938/211385155-e912b458-d652-4afc-a03a-ddd9596a063f.png)


Embed() contained two hard-coded base64 scripts, which it decrypted and wrote into an XML file in the %public% directory and a vbs code file in the public document directory.
 
 ![image](https://user-images.githubusercontent.com/44728938/211385267-96d9bc64-946b-4cfb-801d-32c80430de2b.png)

 ![image](https://user-images.githubusercontent.com/44728938/211385296-5b863286-d11a-4e2f-971d-ec0fa45496c2.png)

 
o	Embed() also appeared to add new registry key to the “run keys”, what will cause the application referenced to be executed when a user logs in. In our case, the value of the new register is the path to embed.vbs (“C:\Users\Public\Documents\embed.vbs”), what makes sure it will be run automatically when the system starts up. The fact that the DLL class was able to modify the run registry key suggests that it was designed to persist on the victim's machine and ensure that the malware is run every time the system starts up. This is a common tactic used by malware to ensure that it remains active and can continue to perform its malicious activities even after the system has been rebooted.
 
![image](https://user-images.githubusercontent.com/44728938/211385341-7f662e08-6e04-419f-b8ff-3aa7501c0629.png)

### Stage 2: embed.vbs
During our analysis of the VBS file 'embed.vbs', we discovered that it was designed to execute another stage of the malware infection process. Specifically, the VBS file used the wscript.shell object to load the 'embed.xml' file into Microsoft MSBuild, which is a software build platform that is used to build and deploy software projects.
The use of MSBuild in this way is an unusual tactic, and suggests that the attackers may be attempting to evade detection by using a legitimate tool in a malicious manner. It is also possible that the attackers are using.
 
 ![image](https://user-images.githubusercontent.com/44728938/211385518-0cbe0d0b-78da-49de-9de8-3d1e1709b291.png)

### Stage 3: embed.xml
The XML scheme is pretty simple, and contains a piece of C# code that should be executed when the XML is loaded into MSBuild.

 ![image](https://user-images.githubusercontent.com/44728938/211385528-6f8858cf-6a73-4bb4-9e15-317ceac5d2b0.png)

During my analysis of the C# code, I took the time to re-organize it in a more readable manner in order to better understand what it was doing. After doing so, I was able to gain a clearer understanding of the code was performing a number of different tasks, including:
* Taking a base64 string and decoding it
* De-compress the string with System.IO.Compression.DeflateStream
* Writing it to memory stream by System.IO.MemoryStream

![image](https://user-images.githubusercontent.com/44728938/211385563-5ac82670-3973-4cd5-b8de-273d49bce790.png)

 
In order to understand what this string is aiming to do, I have manually copied the base64 to CyberChef. I added the filters to mimic the C# execution, and built a recipe consisted of Base64 decode and raw inflation. By doing this, I could see that the output looks exactly as a Windows executable file: the first 2 bytes are ‘MZ’ and the ‘This program cannot be run in DOS mode’ string presents.  You can check the recipe here: 
https://gchq.github.io/CyberChef/#recipe=From_Base64('A-Za-z0-9%2B/%3D',true,false)Raw_Inflate(0,0,'Adaptive',false,false)

![image](https://user-images.githubusercontent.com/44728938/211385746-0e1623df-0f86-4790-944f-59dac38613bb.png)

 
### Stage 4- bk1ha411.4nu.exe
The PE file we’ve got after decompressing and decoding the data is the next component of this infection chain. I’ve exported the file from Cyberchef so I get analyze it separately to determine what it is. Apparently, the file is also a .Net framework file, with the original name of bk1ha411.4nu.exe. 
During the .Net analysis, using dnSpy, I noticed that the PE file has a class and a namespace called ‘GruntStager’. GruntStager, a component of a publicly available toolset named Covenant, is designed to communicate with a pre-set Command and Control (C2) server and pull down a piece of malware onto the victim's machine. In our case the attackers set the C2 server to be the address: hxxp://srv.masterchiefsgruntemporium[.]local:80.

![image](https://user-images.githubusercontent.com/44728938/211385912-daaa8e49-da42-4f94-a6df-7882856bb69c.png)

Unfortunately, during the time of writing this blog, the server is down, and I was not able to determine what malware would be pull down on the last stage.


#### IOCs:

|File |Type |IOC|
|--|--|--|
|Malware.cryptlib64.dll|sha256|732F235784CD2A40C82847B4700FB73175221C6AE6C5F7200A3F43F209989387|
| |sha1|62D77E7CEEA7EC81C3B4CB77893CD8E06E0FEBB0|
| |md5|361E6EDB47E711A72C7F8EE3C0C1632B|
|Embed.xml|sha256|F1548CD02784606C8ABAC865ABF5ED6220D34EEA88C7A5715E0183D7F050F4AB|
| |sha1|059D5028082C1D0323133615E95F90F0D0C90AD7|
| |md5|000FF2048F094552DB03E446B25D4441
| |Path |%Public%\embed.xml|
|Embed.vbs|sha256|66FD543F31545082CF8FCC45A6AB1094BC118C45634F2BE450F84F4E5745B291|
| |sha1|CA80EDB1F361696A505260953D44D3CCD7B77A8A|
| |md5|2C7CAE7EA80F8AD5EB4412DF76615BC1|
|bk1ha411.4nu.exe|C2 domian|hxxp://srv.masterchiefsgruntemporium[.]local:80|
